# OIP v0.1 (Draft)
## Operational Identity Protocol — Deterministic Attribution for Autonomous Systems

### Abstract
OIP specifies a minimal, deterministic framework to bind **operational identity** to **verifiable action events** generated by autonomous and AI-driven systems. It enables **cryptographic attribution**, **tamper-evident event chains**, and **fail-closed verification** for safety auditing and forensic reconstruction.

---

## 1. Scope
OIP applies to entities that act in the physical or digital world, including:
- robots, drones, vehicles, industrial machines
- AI agents and runtimes
- operators (human or automated supervisors)
- infrastructure controllers

OIP defines:
- Operational Identity Object (OID)
- Action Event Object (AEO)
- deterministic `event_id` computation
- signing rules
- chain linkage rules
- verification rules and fail-closed outcomes
- optional anchoring interfaces (non-normative)

Transport, storage backends, and actuation policies are explicitly out of scope.

---

## 2. Terminology
- **Entity:** Any acting component (robot, drone, AI runtime, operator).
- **OID (Operational Identity):** Minimal identity record for an entity.
- **AEO (Action Event Object):** Canonical event describing an action and its digests.
- **Digest:** Hash output (default: SHA-256).
- **Signature:** Digital signature (default: Ed25519).
- **Fail-Closed:** If verification requirements are not met, the event is not trusted.

---

## 3. Design Principles (Normative)
1. Deterministic verification (no subjective interpretation).
2. Minimal disclosure (store digests, not raw sensitive payloads).
3. Append-only chains (events link to previous event hash).
4. Fail-closed validation outputs.
5. Implementation portability (HW/SW agnostic).

---

## 4. Cryptographic Requirements (Normative)
### 4.1 Algorithms
- Hash: **SHA-256** MUST be supported.
- Signature: **Ed25519** MUST be supported.

### 4.2 Canonical JSON (Determinism)
Implementations MUST canonicalize JSON prior to hashing and signing.

A compliant canonicalization MUST:
- encode as UTF-8
- sort object keys lexicographically
- use no insignificant whitespace
- reject non-deterministic numeric representations

**Fail-closed rule:** floats / NaN / Infinity MUST be rejected.

Recommended: RFC 8785 (JSON Canonicalization Scheme). If not used, an equivalent deterministic canonicalization MUST be documented.

---

## 5. Operational Identity Object (OID) (Normative)
The OID binds an entity to a public key and integrity-relevant digests.

### 5.1 OID Fields
Required fields:
- `oid` (string): globally unique identifier (UUID or equivalent)
- `public_key` (string): Ed25519 public key (base64 or hex)
- `manufacturer_id` (string): vendor/manufacturer identifier
- `firmware_hash` (string): SHA-256 digest (hex)
- `created_at` (string): ISO 8601 timestamp
- `status` (string): `ACTIVE` | `REVOKED` | `SUSPENDED`

Optional fields:
- `model_hash` (string|null): SHA-256 digest (hex) of AI model

See `schema/oip-identity.schema.json`.

---

## 6. Action Event Object (AEO) (Normative)
An AEO represents a single action at a point in time, linked into a chain.

### 6.1 AEO Fields
Required fields:
- `event_id` (string): SHA-256 digest (hex) computed as specified in §6.2
- `oid` (string): OID identifier reference
- `timestamp` (string): ISO 8601 timestamp (synchronized source recommended)
- `sequence` (integer): monotonic per `oid` (starts at 1)
- `prev_event_hash` (string|null): previous `event_id` (null for genesis)
- `action_type` (string): stable string identifier (enum-like)
- `risk_level` (string): `R0`..`R5`
- `input_digest` (string): SHA-256 digest (hex)
- `decision_digest` (string): SHA-256 digest (hex)
- `state_digest` (string): SHA-256 digest (hex)
- `firmware_hash` (string): SHA-256 digest (hex); MUST match OID
- `model_hash` (string|null): if OID has `model_hash`, MUST match OID
- `signature` (string): Ed25519 signature as specified in §6.3

See `schema/oip-event.schema.json`.

### 6.2 Event Body for Hashing and `event_id` Computation (Normative)
To eliminate circularity and guarantee interoperability, OIP defines a strict hashed body:

Let `Body` be the AEO object with the following fields **excluded**:
- `event_id`
- `signature`

Then:
- `event_id = SHA256( CanonicalJSON(Body) )`

**Fail-closed rule:** if canonicalization differs, verification MUST fail.

### 6.3 Signing (Normative)
The signature MUST be computed over the same `Body` defined in §6.2:

- `signature = Ed25519Sign( private_key(oid), CanonicalJSON(Body) )`

---

## 7. Verification Engine (Normative)
A verifier MUST output exactly one of:
- `VALID`
- `INVALID`
- `INCOMPLETE`
- `REVOKED`

### 7.1 Verification Conditions
An event is `VALID` iff all conditions hold:
1. OID schema valid.
2. AEO schema valid.
3. OID exists and `status == ACTIVE`.
4. `oid` in event equals `oid` in provided OID record.
5. `firmware_hash` in event equals `firmware_hash` in OID.
6. If OID has `model_hash`, event `model_hash` MUST match.
7. Recomputed `event_id` (per §6.2) equals event `event_id`.
8. Signature verifies against the OID public key over `Body` (per §6.3).
9. If `prev_event_hash` is non-null, the verifier MUST enforce:
   - prior event exists in the chain context
   - `sequence == prev.sequence + 1`
   - `prev_event_hash == prev.event_id`
   - `oid` matches across the chain

### 7.2 Output Semantics
- `REVOKED`: OID status is REVOKED.
- `INCOMPLETE`: required dependencies are missing (e.g., OID not available, missing required fields).
- `INVALID`: event is provably wrong (bad signature, mismatched event_id, broken chain, mismatched firmware/model binding).
- `VALID`: all checks pass.

---

## 8. Fail-Closed Rules (Normative)
Systems MUST NOT treat events as trusted if status is not `VALID`.

Integrators MAY define local policies for handling non-VALID outcomes, including:
- logging
- alarms
- safe mode
- actuation blocking for safety-critical operations

---

## 9. Optional Anchoring (Non-Normative)
For high-risk events (`R3`..`R5`), implementations MAY anchor `event_id` to:
- append-only registries (OEM or federated)
- transparency logs
- public ledgers

Anchoring is not required for local operation.

---

## 10. Security Considerations
OIP mitigates:
- log tampering (signature + event_id)
- event deletion (hash-linked chain expectations)
- replay (sequence + prev hash)
- hidden rollback (firmware/model binding)

OIP does not fully mitigate:
- physical compromise of hardware
- key theft without revocation visibility
- sensor spoofing prior to input digesting

---

## 11. Interoperability Notes
- Transport is out of scope (CAN, DDS, HTTP, MQTT, file logs are all acceptable).
- Canonical JSON determinism is mandatory for cross-vendor interoperability.

---

## 12. Versioning
- Spec versions follow `vMAJOR.MINOR`.
- Backward incompatible changes increment MAJOR.
