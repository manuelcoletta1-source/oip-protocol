# OIP v0.1 (Draft)
## Operational Identity Protocol â€” Deterministic Attribution for Autonomous Systems

### Abstract
OIP specifies a minimal, deterministic framework to bind **operational identity** to **verifiable action events** generated by autonomous and AI-driven systems. It enables **cryptographic attribution**, **tamper-evident event chains**, and **fail-closed verification** for safety auditing and forensic reconstruction.

### 1. Scope
OIP applies to entities that act in the physical or digital world, including:
- robots, drones, vehicles, industrial machines
- AI agents and runtimes
- operators (human or automated supervisors)
- infrastructure controllers

OIP defines:
- Operational Identity Object (OID)
- Action Event Object (AEO)
- Verification rules and fail-closed outcomes
- Optional anchoring interfaces (non-normative)

### 2. Terminology
- **Entity:** Any acting component (robot, drone, AI runtime, operator).
- **OID (Operational Identity):** Minimal identity record for an entity.
- **AEO (Action Event Object):** Canonical event describing an action and its digests.
- **Digest:** Hash output (default: SHA-256).
- **Signature:** Digital signature (default: Ed25519).
- **Fail-Closed:** If verification requirements are not met, the event is invalid for operational trust.

### 3. Design Principles (Normative)
1. Deterministic verification (no subjective interpretation).
2. Minimal disclosure (store digests, not raw sensitive payloads).
3. Append-only chains (events link to previous event hash).
4. Fail-closed validation outputs.
5. Implementation portability (HW/SW agnostic).

### 4. Cryptographic Requirements (Normative)
- Hash: **SHA-256** MUST be supported.
- Signature: **Ed25519** MUST be supported.
- Canonical JSON: Implementations MUST canonicalize JSON before hashing/signing.
  Recommended: RFC 8785 (JSON Canonicalization Scheme). If not used, an implementation MUST document an equivalent deterministic canonicalization strategy.

### 5. Operational Identity Object (OID) (Normative)
The OID binds an entity to a public key and to integrity-relevant digests.

#### 5.1 OID Fields
Minimal OID (JSON):
- `oid` (string): globally unique identifier (UUID or equivalent)
- `public_key` (string): Ed25519 public key (base64 or hex)
- `manufacturer_id` (string): vendor/manufacturer identifier (free-form)
- `firmware_hash` (string): SHA-256 digest of firmware / runtime image
- `model_hash` (string|null): SHA-256 digest of AI model (optional but recommended)
- `created_at` (string): ISO 8601 timestamp
- `status` (string): `ACTIVE` | `REVOKED` | `SUSPENDED`

See `schema/oip-identity.schema.json`.

### 6. Action Event Object (AEO) (Normative)
An AEO represents a single action at a point in time, linked into a chain.

#### 6.1 AEO Fields
Minimal AEO (JSON):
- `event_id` (string): SHA-256 digest of the canonical event body (excluding `signature`)
- `oid` (string): OID reference
- `timestamp` (string): ISO 8601 timestamp (synchronized source recommended)
- `sequence` (integer): monotonic per OID (starts at 1)
- `prev_event_hash` (string|null): previous `event_id` (null for genesis)
- `action_type` (string): stable enum-like string (e.g., `navigation_decision`)
- `risk_level` (string): `R0`..`R5`
- `input_digest` (string): SHA-256 digest of canonicalized input snapshot or reference bundle
- `decision_digest` (string): SHA-256 digest of decision artifact (policy output, plan, controller output)
- `state_digest` (string): SHA-256 digest of internal state snapshot (minimal)
- `firmware_hash` (string): must match OID firmware_hash at the time of emission
- `model_hash` (string|null): must match OID model_hash if set
- `signature` (string): Ed25519 signature over canonical event body (excluding `signature`)

See `schema/oip-event.schema.json`.

#### 6.2 Event ID Computation
`event_id = SHA256( CanonicalJSON( event_body_without_signature ) )`

#### 6.3 Signing
`signature = Ed25519Sign( private_key(oid), CanonicalJSON(event_body_without_signature) )`

### 7. Verification Engine (Normative)
A verifier MUST output exactly one of:
- `VALID`
- `INVALID`
- `INCOMPLETE`
- `REVOKED`

#### 7.1 Verification Conditions
An event is `VALID` iff all conditions hold:
1. Schema valid (OID + AEO).
2. OID exists and `status == ACTIVE`.
3. `firmware_hash` in event equals OID firmware hash at issuance time.
4. If `model_hash` is present in OID, event `model_hash` MUST match.
5. Canonicalization is deterministic and consistent with `event_id`.
6. Signature verifies against OID public key.
7. `sequence` is monotonic and consistent with stored chain state.
8. `prev_event_hash` matches the prior event in the chain (if not genesis).

If any required field is missing or unverifiable -> `INCOMPLETE` or `INVALID`:
- Use `INCOMPLETE` when required dependencies are missing (e.g., OID not available locally).
- Use `INVALID` when the event is provably wrong (bad signature, hash mismatch, broken chain).
If OID is revoked -> `REVOKED`.

### 8. Fail-Closed Rules (Normative)
Systems MUST NOT treat events as trusted if status is not `VALID`.

Recommended OEM policies upon non-VALID:
- log locally
- raise alarm
- enter safe mode for R3+ events
- block actuation for safety-critical operations (implementation policy)

### 9. Optional Anchoring (Non-Normative)
For high-risk events (`R3`..`R5`), implementations MAY anchor `event_id` to:
- an append-only registry (OEM or federated)
- a public ledger
- a transparency log

Anchoring is intentionally not required for local operation.

### 10. Security Considerations
OIP mitigates:
- tampering with logs (hash chain + signatures)
- event deletion (append-only chain expectations)
- replay (sequence + prev hash + uniqueness checks)
- hidden rollback (firmware/model hash binding)

OIP does not fully mitigate:
- physical compromise of hardware
- key theft without revocation visibility
- sensor spoofing prior to digesting

### 11. Interoperability Notes
- Transport is out of scope (CAN, DDS, HTTP, MQTT, file-based logs are all acceptable).
- Canonical JSON is mandatory to ensure deterministic hashing across implementations.

### 12. Versioning
- Spec versions follow `vMAJOR.MINOR`.
- Backward incompatible changes increment MAJOR.

END.
